<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>One Piece World Globe</title>
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background: #000;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        }

        #globe-container {
            width: 100vw;
            height: 100vh;
        }

        #hud {
            position: fixed;
            left: 16px;
            bottom: 16px;
            color: #f7f0d9;
            background: rgba(0, 0, 0, 0.55);
            padding: 10px 14px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.4;
            border: 1px solid rgba(255, 255, 255, 0.08);
            pointer-events: none;
        }

        #hud span.key {
            display: inline-block;
            padding: 2px 6px;
            margin: 0 2px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            font-family: monospace;
            background: rgba(255, 255, 255, 0.05);
        }
    </style>
</head>

<body>
    <div id="globe-container"></div>
    <div id="hud">
        <div><strong>One Piece World Globe</strong></div>
        <div>üñ±Ô∏è Left-drag: rotate</div>
        <div>üñ±Ô∏è Scroll: zoom</div>
        <div>‚å®Ô∏è <span class="key">A</span> toggle auto-spin</div>
    </div>

    <!-- THREE r146 (non-module) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        console.log("THREE revision:", THREE.REVISION);

        const container = document.getElementById("globe-container");

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x02040a); // deep night blue

        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            200
        );
        camera.position.set(0, 2.5, 6);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // === LIGHTING ===
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.55);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xfff4d0, 1.1); // warm "sun"
        keyLight.position.set(5, 4, 5);
        scene.add(keyLight);

        const rimLight = new THREE.DirectionalLight(0x88c6ff, 0.6); // cool rim from behind
        rimLight.position.set(-4, 2, -6);
        scene.add(rimLight);

        // === GLOBE ===
        const radius = 2;
        const globeGeometry = new THREE.SphereGeometry(radius, 96, 96);

        const textureLoader = new THREE.TextureLoader();
        console.log("Loading texture: OPWorldMap.jpeg");

        const mapTexture = textureLoader.load(
            "OPWorldMap.jpeg",
            function (tex) {
                console.log("Texture loaded successfully:", tex);
                tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
                tex.needsUpdate = true;
            },
            undefined,
            function (err) {
                console.error("Error loading texture OPWorldMap.jpeg", err);
            }
        );

        const globeMaterial = new THREE.MeshPhongMaterial({
            map: mapTexture,
            shininess: 12,
            specular: new THREE.Color(0x333333),
            emissive: new THREE.Color(0x080808)
        });

        const globe = new THREE.Mesh(globeGeometry, globeMaterial);
        globe.rotation.z = 0.18; // slight tilt
        scene.add(globe);

        // === ATMOSPHERE / GLOW ===
        const atmosphereGeometry = new THREE.SphereGeometry(radius * 1.06, 96, 96);
        const atmosphereMaterial = new THREE.MeshBasicMaterial({
            color: 0x3fb6ff,
            transparent: true,
            opacity: 0.18,
            blending: THREE.AdditiveBlending,
            side: THREE.BackSide
        });

        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        globe.add(atmosphere);

        // === GRAND LINE & RED LINE ===
        const grandLineGeometry = new THREE.TorusGeometry(radius * 1.01, 0.02, 16, 200);
        const grandLineMaterial = new THREE.MeshBasicMaterial({
            color: 0xffd37a,
            transparent: true,
            opacity: 0.9
        });
        const grandLine = new THREE.Mesh(grandLineGeometry, grandLineMaterial);
        globe.add(grandLine);

        const redLineGeometry = new THREE.TorusGeometry(radius * 1.01, 0.02, 16, 200);
        const redLineMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4b5a,
            transparent: true,
            opacity: 0.9
        });
        const redLine = new THREE.Mesh(redLineGeometry, redLineMaterial);
        redLine.rotation.z = Math.PI / 2;
        globe.add(redLine);

        // === STARFIELD BACKGROUND ===
        (function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 1200;
            const positions = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                const r = 60 + Math.random() * 20;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions[i * 3 + 0] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
            }

            starGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                size: 0.5,
                sizeAttenuation: true,
                color: 0xffffff,
                opacity: 0.8,
                transparent: true
            });

            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        })();

        // === ORBIT CONTROLS ===
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.rotateSpeed = 0.8;
        controls.enablePan = false;
        controls.minDistance = 3;
        controls.maxDistance = 12;
        controls.maxPolarAngle = Math.PI * 0.9;

        // === AUTO-SPIN (TOGGLEABLE) ===
        let autoSpin = false;
        const autoSpinSpeed = 0.003;

        window.addEventListener("keydown", (e) => {
            if (e.key === "a" || e.key === "A") {
                autoSpin = !autoSpin;
                console.log("Auto-spin:", autoSpin);
            }
        });

        // === ANIMATION LOOP ===
        function animate() {
            requestAnimationFrame(animate);

            if (autoSpin) {
                globe.rotation.y += autoSpinSpeed;
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // === RESIZE HANDLING ===
        window.addEventListener("resize", () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
        });
    </script>
</body>

</html>